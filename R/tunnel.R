# Tunnels are for transferring data between tensors. Tunnels do most of the
# argument sanity checks at creation, and try to do the rest only when needed at
# runtime. Overhead reduction is key for smaller tasks.

tunnel <- R6Class(
  "tunnel",
  inherit = alert.recv,
  public = list(
    initialize = function( src,
                           dst,
                           src.perm = NULL,
                           dst.perm = NULL,
                           src.span = NULL,
                           dst.span = NULL,
                           stream   = NULL  ){

      private$.src <- check.tensor( src )
      private$.dst <- check.tensor( dst )

      if( private$.src$type != private$.dst$type ){
        stop( "Tensor types do not match" )
      }
      private$.type <- private$.src$type

      private$.src$listener.add( self )
      private$.dst$listener.add( self )

      # Dim checks
      src.dims <- private$.src$dims
      dst.dims <- private$.dst$dims

      if( !is.null( src.perm ) ){
        private$.src.perm <- check.tensor( src.perm )
        if( private$.src.perm$type != "i" ){
          stop( "Source permutation tensor is not integer" )
        }
        src.dims[[2]] <- private$.src.perm$l
        private$.src.perm$listener.add( self )
      }

      if( !is.null( dst.perm ) ){
        private$.dst.perm <- check.tensor( dst.perm )
        if( private$.dst.perm$type != "i" ){
          stop( "Destination permutation tensor is not integer" )
        }
        dst.dims[[2]] <- private$.dst.perm$l
        private$.dst.perm$listener.add( self )
      }

      if( !is.null( src.span ) ){
        if( any( !is.obj( src.span ),
                 !is.numeric( src.span ),
                 !length( src.span ) == 2,
                 as.logical( src.span %% 1 ),
                 src.span[[2]] > src.dims[[2]],
                 src.span[[1]] > src.span[[2]],
                 src.span[[1]] < 0 ) ){
          stop( "Invalid source span" )
        }

        private$.src.off <- as.integer( src.span[[1]] )
        src.dims[[2]] <- as.integer( src.span[[2]] - src.span[[1]] + 1L )
      }

      if( !is.null( dst.span ) ){
        if( any( !is.obj( dst.span ),
                 !is.numeric( dst.span ),
                 !length( dst.span ) == 2,
                 as.logical( dst.span %% 1 ),
                 dst.span[[2]] > dst.dims[[2]],
                 dst.span[[1]] > dst.span[[2]],
                 dst.span[[1]] < 0 ) ){
          stop( "Invalid destination span" )
        }

        private$.dst.off <- as.integer( dst.span[[1]] )
        dst.dims[[2]] <- as.integer( dst.span[[2]] - dst.span[[1]] + 1L )
      }

      if( !identical( src.dims, dst.dims ) ){
        stop( "Dimensions do not match" )
      }
      private$.dims <- src.dims

      if( !is.null( stream ) ){
        private$.stream <- check.cuda.stream( stream )
        private$.stream$listener.add( self )
      }
    },

    alert = function(){
      private$.check.destroyed()
      print( "Alerted" )
      private$.changed <- TRUE
    },

    transfer = function(){
      private$.check.destroyed()

      if( private$.changed ){
        private$.update()
      }

      private$.transfer(
        src.ptr      = private$.src.ptr,
        dst.ptr      = private$.dst.ptr,
        src.level    = private$.src.level,
        dst.level    = private$.dst.level,
        type         = private$.type,
        dims         = private$.dims,
        src.subs.ptr = private$.src.subs.ptr,
        dst.subs.ptr = private$.dst.subs.ptr,
        src.subs.off = private$.src.off,
        dst.subs.off = private$.dst.off,
        stream       = private$.stream
      )

      invisible( private$.dst )
    },

    destroy = function(){
      private$.check.destroyed()

      private$.listener.remove <- TRUE

      private$.src$listener.remove()
      private$.dst$listener.remove()

      if( !is.null( private$.src.perm ) ){
        private$.src.perm$listener.remove()
      }

      if( !is.null( private$.dst.perm ) ){
        private$.dst.perm$listener.remove()
      }

      if( !is.null( private$.stream ) ){
        private$.stream$listener.remove()
      }

      private$.src      <- NULL
      private$.dst      <- NULL
      private$.src.perm <- NULL
      private$.dst.perm <- NULL
      private$.stream   <- NULL
    }
  ),

  private = list(
    # Original arguments, wrapper objects
    .src          = NULL,
    .dst          = NULL,
    .src.perm     = NULL,
    .dst.perm     = NULL,
    .stream       = NULL,

    # Derived arguments from wrappers
    .dims         = NULL,
    .type         = NULL,
    .src.off      = NULL,
    .dst.off      = NULL,

    # Low level arguments to be updated
    .src.ptr      = NULL,
    .dst.ptr      = NULL,
    .src.level    = NULL,
    .dst.level    = NULL,
    .src.subs.ptr = NULL,
    .dst.subs.ptr = NULL,
    .stream.ptr   = NULL,

    # This function is generated by .update()
    .transfer     = NULL,

    # Update flag
    .changed      = TRUE,

    .update = function(){
      # Since levels are the primary dynamically changing attribute of tensors,
      # these checks mostly concern them
      private$.src.ptr <- private$.src$ptr
      private$.dst.ptr <- private$.dst$ptr

      private$.src.level <- private$.src$level
      private$.dst.level <- private$.dst$level

      low.cross <- ( ( private$.src$is.under && private$.dst$is.deep  ) ||
                     ( private$.src$is.deep  && private$.dst$is.under ) )

      deep.transf <- ( private$.src$is.deep  && private$.dst$is.deep )

      if( !is.null( private$.src$perm ) ){
        if( low.cross ){
          stop( "Source permutation is not available between these levels" )
        }

        if( ( deep.transf  && !private$.src$perm$is.deep ) ||
            ( !deep.transf && private$.src$perm$is.deep  ) ){
          stop( "Source permutation tensor is not on the correct level" )
        }

        private$.src.subs.ptr <- private$.src$perm$ptr
      }

      if( !is.null( private$.dst$perm ) ){
        if( low.cross ){
          stop( "Destination permutation is not available between these levels" )
        }

        if( ( deep.transf  && !private$.dst$perm$is.deep ) ||
            ( !deep.transf && private$.dst$perm$is.deep  ) ){
          stop( "Destiantion permutation tensor is not on the correct level" )
        }

        private$.dst.subs.ptr <- private$.dst$perm$ptr
      }

      if( !is.null( private$.stream ) ){
        if( !is.null( private$.stream$stream ) ){
          if( private$.src.level %in% c(0L, 1L) || private$.dst.level %in% c(0L, 1L) ){
            warning( "An active stream is given to a synchronous transfer" )
          }

          private$.stream.ptr <- private$.stream$stream
        }
      }

      # Multi or single-step transfer
      if( ( private$.src$is.surfaced && private$.dst$is.deep     ) ||
          ( private$.src$is.deep     && private$.dst$is.surfaced ) ){
        private$.transfer <- .transfer.ptr.multi
      }else{
        private$.transfer <- .transfer.ptr
      }

      private$.changed <- FALSE
    },

    .check.destroyed = function(){
      if( self$is.destroyed ){
        stop( "The tunnel is destroyed" )
      }
    }
  ),

  active = list(
    is.destroyed = function( val ){
      if( missing( val ) ) return( is.null( private$.src ) )
    }
  )
)
